<article>
	<header>
		<h3>
			Kafka and Websockets
			<span class="view clickable" onclick="toggleView(this);">
				Show
			</span>

		</h3>
	</header>
	<div style="display: none;">

		<i><p>Posted on <time>Sun Jan 14 2018</time> by <a href="#about">forrestbthomas</a></p></i>
		<p>So, here is my second blog post in as many weeks. Go me! I didn't get as much coding in this week as I would have liked, but that's just kind of the way life goes sometimes. I did a bit of optimization on my deployment for this blog, but that didn't take too much work. It's interesting because with something like this blog, I wonder if I even needed to do it at all. I mean, it's nice that I don't have to do anything other than push to <a href="https://github.com/forrestbthomas">GitHub</a> now and my blog is updated, but I spent several hours setting it up. If I were to count the total time it would take me to simply copy and paste this <code>index.html</code> file over to S3 over the course of my life, I'm not sure it would ever amount to several hours. I guess that's neither here nor there, since it's done now. Lol. It did give me the chance to learn a bit about Git <a href="https://git-scm.com/book/gr/v2/Customizing-Git-Git-Hooks">commit hooks</a> , which was nice. There was one instance in my deployment this week where I had a syntax problem in my <code>config.yml</code> file and didn't know it until it went into <a href="https://circleci.com">CircleCI</a>. Well, that's not ideal, obviously. What I ended up doing is running a <a href="https://npmjs.com/package/yaml-lint">YAML linter</a> before each commit. Supposedly, if that pre-commit hook exits with a non-zero code the commit is supposed to abort. I haven't found that to be the case, but at the very least the YAML linter runs every commit and outputs any errors, so I can always make changes and commit again. </p>
		<p>I also got to spend a little bit of time with my Kafka/Twitter project. This time on the <a href="https://github.com/forrestbthomas/kafka-frontend">front end</a>. As you may have guessed from my previous post, front end development isn't at the top of my list of interests, but I do enjoy it at times. This was one of them. My setup so far is pretty straightforward. I have a <a href="https://kafka.apache.org/">Kafka</a> producer that connects to the free <a href="https://developer.twitter.com/en/docs/tweets/filter-realtime/overview">Twitter Streaming API</a> and filters the stream on keywords that I specify, then it takes those tweets and puts them on a Kafka topic. Next, I use <a href="http://www.onyxplatform.org/">Onyx</a> as my stream processor and Kafka consumer to read in those tweets, conform them, analyze sentiment, and place those output segments onto a separate Kafka topic. That whole part of the project is written in Clojure and I have to say was a lot of fun. The part I started working on this last week was a front end app that would essentially get those sentiment-analyzed tweets and overlay the sentiment on a map of the US. The sentiment would be represented as colors (0 = red, 2 = yellow, 4 = green) and the tweets would be grouped by lat/long coordinates and placed on a D3 map. I ended up using <a href="https://plot.ly/">Plot.ly</a> for the map because it was way easier than rolling my own D3 outline of the US and also added a nice API on top that made it easier for me to overlay colored bubbles by lat/long coordinates. On the API side of the app, I used raw <a href="https://nodejs.org/en/">Node.js</a> as a static server of assets as well as a consumer of the Kafka topic. That part was interesting and I'm not sure I like my approach yet, so we'll see how it goes. But, basically, it didn't appear as though there was a lot of packages available (or regularly maintained) that turned a Node server into a Kafka consumer, so I just used Node's <a href="https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html">child_process</a> module to run the built-in command line Kafka consumer and used stdout and stderr to determine what to do with the message. I created a websocket connection between the front end and the node server, so that anytime the kafka consumer got a new tweet, it would broadcast that tweet as JSON to all clients (which in my case was just my browser).</p>
		<p>This generally worked and I was happy to see messages flowing from the Twitter Streaming API and appear as color coded bubbles on my Plot.ly map, but there are certainly some areas that need tweaking. For one, I'm not sure I need a websocket server. There really isn't a need to have bi-directional communication in my use case since the front end is purely static and there isn't even a way for the front end to communicate with the back end at this point. I could just as easily have used regular old HTTP and been just fine. Part of me wonders, though, if I might want to add the ability for the front end to toggle the stream in some way. For example, if I wanted to pause the display of tweets, rewind and playback old tweets for recording and saving, or even add the ability to change keywords on the stream in real-time. There is <i>probably</i> a reason to keep using websockets, so I think I will, but it's good to consider other options. The other that could use some tweaking is the Plot.ly integration. Right now, I'm using an API from Plot.ly that allows me to read in a file (JSON or CSV) and it will plot the graoh accordingly. This is really useful if I already have a data set saved to disk or if I have a static file stored in the cloud. But when I have streaming data that changes constantly, I am having to redraw the whole graph every time. That's gross. And I don't like it. There are definitely better ways of handling the updating of graph data and its display, so I will probably be looking into that this week.</p>
		<p>Well, that's all I have for now. Hopefully, next week I can provide an update on my front end tweaks (if I get around to them) or some other thing that I have learned. Thanks for reading. Take care.</p>
	</div>
</article>
<hr>
